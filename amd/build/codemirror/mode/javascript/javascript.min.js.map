{"version":3,"file":"javascript.min.js","sources":["../../../../src/codemirror/mode/javascript/javascript.js"],"sourcesContent":["/*eslint-disable*/\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n    if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n      mod(require(\"../../lib/codemirror\"));\n    else if (typeof define == \"function\" && define.amd) // AMD\n      define([\"../../lib/codemirror\"], mod);\n    else // Plain browser env\n      mod(CodeMirror);\n  })(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n    var indentUnit = config.indentUnit;\n    var statementIndent = parserConfig.statementIndent;\n    var jsonldMode = parserConfig.jsonld;\n    var jsonMode = parserConfig.json || jsonldMode;\n    var trackScope = parserConfig.trackScope !== false\n    var isTS = parserConfig.typescript;\n    var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n    // Tokenizer\n\n    var keywords = function(){\n      function kw(type) {return {type: type, style: \"keyword\"};}\n      var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n      var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n      return {\n        \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n        \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n        \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n        \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n        \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n        \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n        \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n        \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n        \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n        \"await\": C\n      };\n    }();\n\n    var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n    var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n    function readRegexp(stream) {\n      var escaped = false, next, inSet = false;\n      while ((next = stream.next()) != null) {\n        if (!escaped) {\n          if (next == \"/\" && !inSet) return;\n          if (next == \"[\") inSet = true;\n          else if (inSet && next == \"]\") inSet = false;\n        }\n        escaped = !escaped && next == \"\\\\\";\n      }\n    }\n\n    // Used as scratch variables to communicate multiple values without\n    // consing up tons of objects.\n    var type, content;\n    function ret(tp, style, cont) {\n      type = tp; content = cont;\n      return style;\n    }\n    function tokenBase(stream, state) {\n      var ch = stream.next();\n      if (ch == '\"' || ch == \"'\") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n        return ret(\"number\", \"number\");\n      } else if (ch == \".\" && stream.match(\"..\")) {\n        return ret(\"spread\", \"meta\");\n      } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n        return ret(ch);\n      } else if (ch == \"=\" && stream.eat(\">\")) {\n        return ret(\"=>\", \"operator\");\n      } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n        return ret(\"number\", \"number\");\n      } else if (/\\d/.test(ch)) {\n        stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n        return ret(\"number\", \"number\");\n      } else if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n          state.tokenize = tokenComment;\n          return tokenComment(stream, state);\n        } else if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return ret(\"comment\", \"comment\");\n        } else if (expressionAllowed(stream, state, 1)) {\n          readRegexp(stream);\n          stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n          return ret(\"regexp\", \"string-2\");\n        } else {\n          stream.eat(\"=\");\n          return ret(\"operator\", \"operator\", stream.current());\n        }\n      } else if (ch == \"`\") {\n        state.tokenize = tokenQuasi;\n        return tokenQuasi(stream, state);\n      } else if (ch == \"#\" && stream.peek() == \"!\") {\n        stream.skipToEnd();\n        return ret(\"meta\", \"meta\");\n      } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n        return ret(\"variable\", \"property\")\n      } else if (ch == \"<\" && stream.match(\"!--\") ||\n                 (ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start)))) {\n        stream.skipToEnd()\n        return ret(\"comment\", \"comment\")\n      } else if (isOperatorChar.test(ch)) {\n        if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n          if (stream.eat(\"=\")) {\n            if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n          } else if (/[<>*+\\-|&?]/.test(ch)) {\n            stream.eat(ch)\n            if (ch == \">\") stream.eat(ch)\n          }\n        }\n        if (ch == \"?\" && stream.eat(\".\")) return ret(\".\")\n        return ret(\"operator\", \"operator\", stream.current());\n      } else if (wordRE.test(ch)) {\n        stream.eatWhile(wordRE);\n        var word = stream.current()\n        if (state.lastType != \".\") {\n          if (keywords.propertyIsEnumerable(word)) {\n            var kw = keywords[word]\n            return ret(kw.type, kw.style, word)\n          }\n          if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n            return ret(\"async\", \"keyword\", word)\n        }\n        return ret(\"variable\", \"variable\", word)\n      }\n    }\n\n    function tokenString(quote) {\n      return function(stream, state) {\n        var escaped = false, next;\n        if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n          state.tokenize = tokenBase;\n          return ret(\"jsonld-keyword\", \"meta\");\n        }\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) break;\n          escaped = !escaped && next == \"\\\\\";\n        }\n        if (!escaped) state.tokenize = tokenBase;\n        return ret(\"string\", \"string\");\n      };\n    }\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false, ch;\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = tokenBase;\n          break;\n        }\n        maybeEnd = (ch == \"*\");\n      }\n      return ret(\"comment\", \"comment\");\n    }\n\n    function tokenQuasi(stream, state) {\n      var escaped = false, next;\n      while ((next = stream.next()) != null) {\n        if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n          state.tokenize = tokenBase;\n          break;\n        }\n        escaped = !escaped && next == \"\\\\\";\n      }\n      return ret(\"quasi\", \"string-2\", stream.current());\n    }\n\n    var brackets = \"([{}])\";\n    // This is a crude lookahead trick to try and notice that we're\n    // parsing the argument patterns for a fat-arrow function before we\n    // actually hit the arrow token. It only works if the arrow is on\n    // the same line as the arguments and there's no strange noise\n    // (comments) in between. Fallback is to only notice when we hit the\n    // arrow, and not declare the arguments as locals for the arrow\n    // body.\n    function findFatArrow(stream, state) {\n      if (state.fatArrowAt) state.fatArrowAt = null;\n      var arrow = stream.string.indexOf(\"=>\", stream.start);\n      if (arrow < 0) return;\n\n      if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n        var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n        if (m) arrow = m.index\n      }\n\n      var depth = 0, sawSomething = false;\n      for (var pos = arrow - 1; pos >= 0; --pos) {\n        var ch = stream.string.charAt(pos);\n        var bracket = brackets.indexOf(ch);\n        if (bracket >= 0 && bracket < 3) {\n          if (!depth) { ++pos; break; }\n          if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n        } else if (bracket >= 3 && bracket < 6) {\n          ++depth;\n        } else if (wordRE.test(ch)) {\n          sawSomething = true;\n        } else if (/[\"'\\/`]/.test(ch)) {\n          for (;; --pos) {\n            if (pos == 0) return\n            var next = stream.string.charAt(pos - 1)\n            if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") { pos--; break }\n          }\n        } else if (sawSomething && !depth) {\n          ++pos;\n          break;\n        }\n      }\n      if (sawSomething && !depth) state.fatArrowAt = pos;\n    }\n\n    // Parser\n\n    var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true,\n                       \"regexp\": true, \"this\": true, \"import\": true, \"jsonld-keyword\": true};\n\n    function JSLexical(indented, column, type, align, prev, info) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.prev = prev;\n      this.info = info;\n      if (align != null) this.align = align;\n    }\n\n    function inScope(state, varname) {\n      if (!trackScope) return false\n      for (var v = state.localVars; v; v = v.next)\n        if (v.name == varname) return true;\n      for (var cx = state.context; cx; cx = cx.prev) {\n        for (var v = cx.vars; v; v = v.next)\n          if (v.name == varname) return true;\n      }\n    }\n\n    function parseJS(state, style, type, content, stream) {\n      var cc = state.cc;\n      // Communicate our context to the combinators.\n      // (Less wasteful than consing up a hundred closures on every call.)\n      cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n      if (!state.lexical.hasOwnProperty(\"align\"))\n        state.lexical.align = true;\n\n      while(true) {\n        var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n        if (combinator(type, content)) {\n          while(cc.length && cc[cc.length - 1].lex)\n            cc.pop()();\n          if (cx.marked) return cx.marked;\n          if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n          return style;\n        }\n      }\n    }\n\n    // Combinator utils\n\n    var cx = {state: null, column: null, marked: null, cc: null};\n    function pass() {\n      for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n    }\n    function cont() {\n      pass.apply(null, arguments);\n      return true;\n    }\n    function inList(name, list) {\n      for (var v = list; v; v = v.next) if (v.name == name) return true\n      return false;\n    }\n    function register(varname) {\n      var state = cx.state;\n      cx.marked = \"def\";\n      if (!trackScope) return\n      if (state.context) {\n        if (state.lexical.info == \"var\" && state.context && state.context.block) {\n          // FIXME function decls are also not block scoped\n          var newContext = registerVarScoped(varname, state.context)\n          if (newContext != null) {\n            state.context = newContext\n            return\n          }\n        } else if (!inList(varname, state.localVars)) {\n          state.localVars = new Var(varname, state.localVars)\n          return\n        }\n      }\n      // Fall through means this is global\n      if (parserConfig.globalVars && !inList(varname, state.globalVars))\n        state.globalVars = new Var(varname, state.globalVars)\n    }\n    function registerVarScoped(varname, context) {\n      if (!context) {\n        return null\n      } else if (context.block) {\n        var inner = registerVarScoped(varname, context.prev)\n        if (!inner) return null\n        if (inner == context.prev) return context\n        return new Context(inner, context.vars, true)\n      } else if (inList(varname, context.vars)) {\n        return context\n      } else {\n        return new Context(context.prev, new Var(varname, context.vars), false)\n      }\n    }\n\n    function isModifier(name) {\n      return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n    }\n\n    // Combinators\n\n    function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n    function Var(name, next) { this.name = name; this.next = next }\n\n    var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n    function pushcontext() {\n      cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n      cx.state.localVars = defaultVars\n    }\n    function pushblockcontext() {\n      cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n      cx.state.localVars = null\n    }\n    pushcontext.lex = pushblockcontext.lex = true\n    function popcontext() {\n      cx.state.localVars = cx.state.context.vars\n      cx.state.context = cx.state.context.prev\n    }\n    popcontext.lex = true\n    function pushlex(type, info) {\n      var result = function() {\n        var state = cx.state, indent = state.indented;\n        if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n        else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n          indent = outer.indented;\n        state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n      };\n      result.lex = true;\n      return result;\n    }\n    function poplex() {\n      var state = cx.state;\n      if (state.lexical.prev) {\n        if (state.lexical.type == \")\")\n          state.indented = state.lexical.indented;\n        state.lexical = state.lexical.prev;\n      }\n    }\n    poplex.lex = true;\n\n    function expect(wanted) {\n      function exp(type) {\n        if (type == wanted) return cont();\n        else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n        else return cont(exp);\n      };\n      return exp;\n    }\n\n    function statement(type, value) {\n      if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n      if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n      if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n      if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n      if (type == \"debugger\") return cont(expect(\";\"));\n      if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n      if (type == \";\") return cont();\n      if (type == \"if\") {\n        if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n          cx.state.cc.pop()();\n        return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n      }\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"for\") return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n      if (type == \"class\" || (isTS && value == \"interface\")) {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n      }\n      if (type == \"variable\") {\n        if (isTS && value == \"declare\") {\n          cx.marked = \"keyword\"\n          return cont(statement)\n        } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n          cx.marked = \"keyword\"\n          if (value == \"enum\") return cont(enumdef);\n          else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n          else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n        } else if (isTS && value == \"namespace\") {\n          cx.marked = \"keyword\"\n          return cont(pushlex(\"form\"), expression, statement, poplex)\n        } else if (isTS && value == \"abstract\") {\n          cx.marked = \"keyword\"\n          return cont(statement)\n        } else {\n          return cont(pushlex(\"stat\"), maybelabel);\n        }\n      }\n      if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                        block, poplex, poplex, popcontext);\n      if (type == \"case\") return cont(expression, expect(\":\"));\n      if (type == \"default\") return cont(expect(\":\"));\n      if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n      if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n      if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n      if (type == \"async\") return cont(statement)\n      if (value == \"@\") return cont(expression, statement)\n      return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n    }\n    function maybeCatchBinding(type) {\n      if (type == \"(\") return cont(funarg, expect(\")\"))\n    }\n    function expression(type, value) {\n      return expressionInner(type, value, false);\n    }\n    function expressionNoComma(type, value) {\n      return expressionInner(type, value, true);\n    }\n    function parenExpr(type) {\n      if (type != \"(\") return pass()\n      return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex)\n    }\n    function expressionInner(type, value, noComma) {\n      if (cx.state.fatArrowAt == cx.stream.start) {\n        var body = noComma ? arrowBodyNoComma : arrowBody;\n        if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n        else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n      }\n\n      var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n      if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n      if (type == \"function\") return cont(functiondef, maybeop);\n      if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n      if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n      if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n      if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n      if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n      if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n      if (type == \"quasi\") return pass(quasi, maybeop);\n      if (type == \"new\") return cont(maybeTarget(noComma));\n      return cont();\n    }\n    function maybeexpression(type) {\n      if (type.match(/[;\\}\\)\\],]/)) return pass();\n      return pass(expression);\n    }\n\n    function maybeoperatorComma(type, value) {\n      if (type == \",\") return cont(maybeexpression);\n      return maybeoperatorNoComma(type, value, false);\n    }\n    function maybeoperatorNoComma(type, value, noComma) {\n      var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n      var expr = noComma == false ? expression : expressionNoComma;\n      if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n      if (type == \"operator\") {\n        if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n        if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n          return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n        if (value == \"?\") return cont(expression, expect(\":\"), expr);\n        return cont(expr);\n      }\n      if (type == \"quasi\") { return pass(quasi, me); }\n      if (type == \";\") return;\n      if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n      if (type == \".\") return cont(property, me);\n      if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n      if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n      if (type == \"regexp\") {\n        cx.state.lastType = cx.marked = \"operator\"\n        cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n        return cont(expr)\n      }\n    }\n    function quasi(type, value) {\n      if (type != \"quasi\") return pass();\n      if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n      return cont(maybeexpression, continueQuasi);\n    }\n    function continueQuasi(type) {\n      if (type == \"}\") {\n        cx.marked = \"string-2\";\n        cx.state.tokenize = tokenQuasi;\n        return cont(quasi);\n      }\n    }\n    function arrowBody(type) {\n      findFatArrow(cx.stream, cx.state);\n      return pass(type == \"{\" ? statement : expression);\n    }\n    function arrowBodyNoComma(type) {\n      findFatArrow(cx.stream, cx.state);\n      return pass(type == \"{\" ? statement : expressionNoComma);\n    }\n    function maybeTarget(noComma) {\n      return function(type) {\n        if (type == \".\") return cont(noComma ? targetNoComma : target);\n        else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n        else return pass(noComma ? expressionNoComma : expression);\n      };\n    }\n    function target(_, value) {\n      if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n    }\n    function targetNoComma(_, value) {\n      if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n    }\n    function maybelabel(type) {\n      if (type == \":\") return cont(poplex, statement);\n      return pass(maybeoperatorComma, expect(\";\"), poplex);\n    }\n    function property(type) {\n      if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n    }\n    function objprop(type, value) {\n      if (type == \"async\") {\n        cx.marked = \"property\";\n        return cont(objprop);\n      } else if (type == \"variable\" || cx.style == \"keyword\") {\n        cx.marked = \"property\";\n        if (value == \"get\" || value == \"set\") return cont(getterSetter);\n        var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n        if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n          cx.state.fatArrowAt = cx.stream.pos + m[0].length\n        return cont(afterprop);\n      } else if (type == \"number\" || type == \"string\") {\n        cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n        return cont(afterprop);\n      } else if (type == \"jsonld-keyword\") {\n        return cont(afterprop);\n      } else if (isTS && isModifier(value)) {\n        cx.marked = \"keyword\"\n        return cont(objprop)\n      } else if (type == \"[\") {\n        return cont(expression, maybetype, expect(\"]\"), afterprop);\n      } else if (type == \"spread\") {\n        return cont(expressionNoComma, afterprop);\n      } else if (value == \"*\") {\n        cx.marked = \"keyword\";\n        return cont(objprop);\n      } else if (type == \":\") {\n        return pass(afterprop)\n      }\n    }\n    function getterSetter(type) {\n      if (type != \"variable\") return pass(afterprop);\n      cx.marked = \"property\";\n      return cont(functiondef);\n    }\n    function afterprop(type) {\n      if (type == \":\") return cont(expressionNoComma);\n      if (type == \"(\") return pass(functiondef);\n    }\n    function commasep(what, end, sep) {\n      function proceed(type, value) {\n        if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n          var lex = cx.state.lexical;\n          if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n          return cont(function(type, value) {\n            if (type == end || value == end) return pass()\n            return pass(what)\n          }, proceed);\n        }\n        if (type == end || value == end) return cont();\n        if (sep && sep.indexOf(\";\") > -1) return pass(what)\n        return cont(expect(end));\n      }\n      return function(type, value) {\n        if (type == end || value == end) return cont();\n        return pass(what, proceed);\n      };\n    }\n    function contCommasep(what, end, info) {\n      for (var i = 3; i < arguments.length; i++)\n        cx.cc.push(arguments[i]);\n      return cont(pushlex(end, info), commasep(what, end), poplex);\n    }\n    function block(type) {\n      if (type == \"}\") return cont();\n      return pass(statement, block);\n    }\n    function maybetype(type, value) {\n      if (isTS) {\n        if (type == \":\") return cont(typeexpr);\n        if (value == \"?\") return cont(maybetype);\n      }\n    }\n    function maybetypeOrIn(type, value) {\n      if (isTS && (type == \":\" || value == \"in\")) return cont(typeexpr)\n    }\n    function mayberettype(type) {\n      if (isTS && type == \":\") {\n        if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n        else return cont(typeexpr)\n      }\n    }\n    function isKW(_, value) {\n      if (value == \"is\") {\n        cx.marked = \"keyword\"\n        return cont()\n      }\n    }\n    function typeexpr(type, value) {\n      if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n        cx.marked = \"keyword\"\n        return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n      }\n      if (type == \"variable\" || value == \"void\") {\n        cx.marked = \"type\"\n        return cont(afterType)\n      }\n      if (value == \"|\" || value == \"&\") return cont(typeexpr)\n      if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n      if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n      if (type == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType)\n      if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n      if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n      if (type == \"quasi\") { return pass(quasiType, afterType); }\n    }\n    function maybeReturnType(type) {\n      if (type == \"=>\") return cont(typeexpr)\n    }\n    function typeprops(type) {\n      if (type.match(/[\\}\\)\\]]/)) return cont()\n      if (type == \",\" || type == \";\") return cont(typeprops)\n      return pass(typeprop, typeprops)\n    }\n    function typeprop(type, value) {\n      if (type == \"variable\" || cx.style == \"keyword\") {\n        cx.marked = \"property\"\n        return cont(typeprop)\n      } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n        return cont(typeprop)\n      } else if (type == \":\") {\n        return cont(typeexpr)\n      } else if (type == \"[\") {\n        return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop)\n      } else if (type == \"(\") {\n        return pass(functiondecl, typeprop)\n      } else if (!type.match(/[;\\}\\)\\],]/)) {\n        return cont()\n      }\n    }\n    function quasiType(type, value) {\n      if (type != \"quasi\") return pass();\n      if (value.slice(value.length - 2) != \"${\") return cont(quasiType);\n      return cont(typeexpr, continueQuasiType);\n    }\n    function continueQuasiType(type) {\n      if (type == \"}\") {\n        cx.marked = \"string-2\";\n        cx.state.tokenize = tokenQuasi;\n        return cont(quasiType);\n      }\n    }\n    function typearg(type, value) {\n      if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n      if (type == \":\") return cont(typeexpr)\n      if (type == \"spread\") return cont(typearg)\n      return pass(typeexpr)\n    }\n    function afterType(type, value) {\n      if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n      if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n      if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n      if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n      if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n    }\n    function maybeTypeArgs(_, value) {\n      if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    }\n    function typeparam() {\n      return pass(typeexpr, maybeTypeDefault)\n    }\n    function maybeTypeDefault(_, value) {\n      if (value == \"=\") return cont(typeexpr)\n    }\n    function vardef(_, value) {\n      if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n      return pass(pattern, maybetype, maybeAssign, vardefCont);\n    }\n    function pattern(type, value) {\n      if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n      if (type == \"variable\") { register(value); return cont(); }\n      if (type == \"spread\") return cont(pattern);\n      if (type == \"[\") return contCommasep(eltpattern, \"]\");\n      if (type == \"{\") return contCommasep(proppattern, \"}\");\n    }\n    function proppattern(type, value) {\n      if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n        register(value);\n        return cont(maybeAssign);\n      }\n      if (type == \"variable\") cx.marked = \"property\";\n      if (type == \"spread\") return cont(pattern);\n      if (type == \"}\") return pass();\n      if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n      return cont(expect(\":\"), pattern, maybeAssign);\n    }\n    function eltpattern() {\n      return pass(pattern, maybeAssign)\n    }\n    function maybeAssign(_type, value) {\n      if (value == \"=\") return cont(expressionNoComma);\n    }\n    function vardefCont(type) {\n      if (type == \",\") return cont(vardef);\n    }\n    function maybeelse(type, value) {\n      if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n    }\n    function forspec(type, value) {\n      if (value == \"await\") return cont(forspec);\n      if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n    }\n    function forspec1(type) {\n      if (type == \"var\") return cont(vardef, forspec2);\n      if (type == \"variable\") return cont(forspec2);\n      return pass(forspec2)\n    }\n    function forspec2(type, value) {\n      if (type == \")\") return cont()\n      if (type == \";\") return cont(forspec2)\n      if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n      return pass(expression, forspec2)\n    }\n    function functiondef(type, value) {\n      if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n      if (type == \"variable\") {register(value); return cont(functiondef);}\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n      if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n    }\n    function functiondecl(type, value) {\n      if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n      if (type == \"variable\") {register(value); return cont(functiondecl);}\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n      if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n    }\n    function typename(type, value) {\n      if (type == \"keyword\" || type == \"variable\") {\n        cx.marked = \"type\"\n        return cont(typename)\n      } else if (value == \"<\") {\n        return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n      }\n    }\n    function funarg(type, value) {\n      if (value == \"@\") cont(expression, funarg)\n      if (type == \"spread\") return cont(funarg);\n      if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n      if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n      return pass(pattern, maybetype, maybeAssign);\n    }\n    function classExpression(type, value) {\n      // Class expressions may have an optional name.\n      if (type == \"variable\") return className(type, value);\n      return classNameAfter(type, value);\n    }\n    function className(type, value) {\n      if (type == \"variable\") {register(value); return cont(classNameAfter);}\n    }\n    function classNameAfter(type, value) {\n      if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n      if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n        if (value == \"implements\") cx.marked = \"keyword\";\n        return cont(isTS ? typeexpr : expression, classNameAfter);\n      }\n      if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n    }\n    function classBody(type, value) {\n      if (type == \"async\" ||\n          (type == \"variable\" &&\n           (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n           cx.stream.match(/^\\s+#?[\\w$\\xa1-\\uffff]/, false))) {\n        cx.marked = \"keyword\";\n        return cont(classBody);\n      }\n      if (type == \"variable\" || cx.style == \"keyword\") {\n        cx.marked = \"property\";\n        return cont(classfield, classBody);\n      }\n      if (type == \"number\" || type == \"string\") return cont(classfield, classBody);\n      if (type == \"[\")\n        return cont(expression, maybetype, expect(\"]\"), classfield, classBody)\n      if (value == \"*\") {\n        cx.marked = \"keyword\";\n        return cont(classBody);\n      }\n      if (isTS && type == \"(\") return pass(functiondecl, classBody)\n      if (type == \";\" || type == \",\") return cont(classBody);\n      if (type == \"}\") return cont();\n      if (value == \"@\") return cont(expression, classBody)\n    }\n    function classfield(type, value) {\n      if (value == \"!\") return cont(classfield)\n      if (value == \"?\") return cont(classfield)\n      if (type == \":\") return cont(typeexpr, maybeAssign)\n      if (value == \"=\") return cont(expressionNoComma)\n      var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n      return pass(isInterface ? functiondecl : functiondef)\n    }\n    function afterExport(type, value) {\n      if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n      if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n      if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n      return pass(statement);\n    }\n    function exportField(type, value) {\n      if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n      if (type == \"variable\") return pass(expressionNoComma, exportField);\n    }\n    function afterImport(type) {\n      if (type == \"string\") return cont();\n      if (type == \"(\") return pass(expression);\n      if (type == \".\") return pass(maybeoperatorComma);\n      return pass(importSpec, maybeMoreImports, maybeFrom);\n    }\n    function importSpec(type, value) {\n      if (type == \"{\") return contCommasep(importSpec, \"}\");\n      if (type == \"variable\") register(value);\n      if (value == \"*\") cx.marked = \"keyword\";\n      return cont(maybeAs);\n    }\n    function maybeMoreImports(type) {\n      if (type == \",\") return cont(importSpec, maybeMoreImports)\n    }\n    function maybeAs(_type, value) {\n      if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n    }\n    function maybeFrom(_type, value) {\n      if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n    }\n    function arrayLiteral(type) {\n      if (type == \"]\") return cont();\n      return pass(commasep(expressionNoComma, \"]\"));\n    }\n    function enumdef() {\n      return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n    }\n    function enummember() {\n      return pass(pattern, maybeAssign);\n    }\n\n    function isContinuedStatement(state, textAfter) {\n      return state.lastType == \"operator\" || state.lastType == \",\" ||\n        isOperatorChar.test(textAfter.charAt(0)) ||\n        /[,.]/.test(textAfter.charAt(0));\n    }\n\n    function expressionAllowed(stream, state, backUp) {\n      return state.tokenize == tokenBase &&\n        /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n        (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n    }\n\n    // Interface\n\n    return {\n      startState: function(basecolumn) {\n        var state = {\n          tokenize: tokenBase,\n          lastType: \"sof\",\n          cc: [],\n          lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n          localVars: parserConfig.localVars,\n          context: parserConfig.localVars && new Context(null, null, false),\n          indented: basecolumn || 0\n        };\n        if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n          state.globalVars = parserConfig.globalVars;\n        return state;\n      },\n\n      token: function(stream, state) {\n        if (stream.sol()) {\n          if (!state.lexical.hasOwnProperty(\"align\"))\n            state.lexical.align = false;\n          state.indented = stream.indentation();\n          findFatArrow(stream, state);\n        }\n        if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        if (type == \"comment\") return style;\n        state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n        return parseJS(state, style, type, content, stream);\n      },\n\n      indent: function(state, textAfter) {\n        if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n        if (state.tokenize != tokenBase) return 0;\n        var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n        // Kludge to prevent 'maybelse' from blocking lexical scope pops\n        if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n          var c = state.cc[i];\n          if (c == poplex) lexical = lexical.prev;\n          else if (c != maybeelse && c != popcontext) break;\n        }\n        while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n               (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                     (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                     !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n          lexical = lexical.prev;\n        if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n          lexical = lexical.prev;\n        var type = lexical.type, closing = firstChar == type;\n\n        if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n        else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n        else if (type == \"form\") return lexical.indented + indentUnit;\n        else if (type == \"stat\")\n          return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n        else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n          return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n        else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n        else return lexical.indented + (closing ? 0 : indentUnit);\n      },\n\n      electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n      blockCommentStart: jsonMode ? null : \"/*\",\n      blockCommentEnd: jsonMode ? null : \"*/\",\n      blockCommentContinue: jsonMode ? null : \" * \",\n      lineComment: jsonMode ? null : \"//\",\n      fold: \"brace\",\n      closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n      helperType: jsonMode ? \"json\" : \"javascript\",\n      jsonldMode: jsonldMode,\n      jsonMode: jsonMode,\n\n      expressionAllowed: expressionAllowed,\n\n      skipExpression: function(state) {\n        parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null))\n      }\n    };\n  });\n\n  CodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\n  CodeMirror.defineMIME(\"text/javascript\", \"javascript\");\n  CodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\n  CodeMirror.defineMIME(\"application/javascript\", \"javascript\");\n  CodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\n  CodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\n  CodeMirror.defineMIME(\"application/json\", { name: \"javascript\", json: true });\n  CodeMirror.defineMIME(\"application/x-json\", { name: \"javascript\", json: true });\n  CodeMirror.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: true })\n  CodeMirror.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: true });\n  CodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\n  CodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n  });"],"names":["mod","CodeMirror","defineMode","config","parserConfig","type","content","indentUnit","statementIndent","jsonldMode","jsonld","jsonMode","json","trackScope","isTS","typescript","wordRE","wordCharacters","keywords","kw","style","A","B","C","D","operator","atom","isOperatorChar","isJsonldKeyword","ret","tp","cont","tokenBase","stream","state","quote","ch","next","tokenize","escaped","peek","match","test","eat","tokenComment","skipToEnd","expressionAllowed","inSet","readRegexp","current","tokenQuasi","eatWhile","string","slice","start","lexical","word","lastType","propertyIsEnumerable","maybeEnd","findFatArrow","fatArrowAt","arrow","indexOf","m","exec","index","depth","sawSomething","pos","charAt","bracket","atomicTypes","JSLexical","indented","column","align","prev","info","this","inScope","varname","v","localVars","name","cx","context","vars","parseJS","cc","marked","hasOwnProperty","length","pop","expression","statement","lex","pass","i","arguments","push","apply","inList","list","register","block","newContext","registerVarScoped","Var","globalVars","inner","Context","isModifier","defaultVars","pushcontext","pushblockcontext","popcontext","pushlex","result","indent","outer","poplex","expect","wanted","exp","value","vardef","parenExpr","maybeexpression","maybeelse","functiondef","forspec","className","enumdef","typename","typeexpr","pattern","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","body","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","classExpression","arrayLiteral","contCommasep","objprop","quasi","targetNoComma","target","maybeTypeArgs","maybeTarget","me","expr","property","backUp","continueQuasi","_","getterSetter","afterprop","maybetype","what","end","sep","proceed","maybetypeOrIn","mayberettype","isKW","afterType","typeprops","typearg","maybeReturnType","quasiType","typeprop","functiondecl","continueQuasiType","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","startState","basecolumn","token","sol","indentation","eatSpace","textAfter","Pass","top","firstChar","c","closing","isContinuedStatement","doubleIndentSwitch","electricInput","blockCommentStart","blockCommentEnd","blockCommentContinue","lineComment","fold","closeBrackets","helperType","skipExpression","StringStream","registerHelper","defineMIME","exports","module","require","define","amd"],"mappings":"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"}