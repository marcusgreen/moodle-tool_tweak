{"version":3,"file":"xml.min.js","sources":["../../../../src/codemirror/mode/xml/xml.js"],"sourcesContent":["/*eslint-disable*/\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n    if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n      mod(require(\"../../lib/codemirror\"));\n    else if (typeof define == \"function\" && define.amd) // AMD\n      define([\"../../lib/codemirror\"], mod);\n    else // Plain browser env\n      mod(CodeMirror);\n  })(function(CodeMirror) {\n  \"use strict\";\n\n  var htmlConfig = {\n    autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                      'track': true, 'wbr': true, 'menuitem': true},\n    implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                       'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                       'th': true, 'tr': true},\n    contextGrabbers: {\n      'dd': {'dd': true, 'dt': true},\n      'dt': {'dd': true, 'dt': true},\n      'li': {'li': true},\n      'option': {'option': true, 'optgroup': true},\n      'optgroup': {'optgroup': true},\n      'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n            'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n            'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n            'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n            'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n      'rp': {'rp': true, 'rt': true},\n      'rt': {'rp': true, 'rt': true},\n      'tbody': {'tbody': true, 'tfoot': true},\n      'td': {'td': true, 'th': true},\n      'tfoot': {'tbody': true},\n      'th': {'td': true, 'th': true},\n      'thead': {'tbody': true, 'tfoot': true},\n      'tr': {'tr': true}\n    },\n    doNotIndent: {\"pre\": true},\n    allowUnquoted: true,\n    allowMissing: true,\n    caseFold: true\n  }\n\n  var xmlConfig = {\n    autoSelfClosers: {},\n    implicitlyClosed: {},\n    contextGrabbers: {},\n    doNotIndent: {},\n    allowUnquoted: false,\n    allowMissing: false,\n    allowMissingTagName: false,\n    caseFold: false\n  }\n\n  CodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n    var indentUnit = editorConf.indentUnit\n    var config = {}\n    var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n    for (var prop in defaults) config[prop] = defaults[prop]\n    for (var prop in config_) config[prop] = config_[prop]\n\n    // Return variables for tokenizers\n    var type, setStyle;\n\n    function inText(stream, state) {\n      function chain(parser) {\n        state.tokenize = parser;\n        return parser(stream, state);\n      }\n\n      var ch = stream.next();\n      if (ch == \"<\") {\n        if (stream.eat(\"!\")) {\n          if (stream.eat(\"[\")) {\n            if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n            else return null;\n          } else if (stream.match(\"--\")) {\n            return chain(inBlock(\"comment\", \"-->\"));\n          } else if (stream.match(\"DOCTYPE\", true, true)) {\n            stream.eatWhile(/[\\w\\._\\-]/);\n            return chain(doctype(1));\n          } else {\n            return null;\n          }\n        } else if (stream.eat(\"?\")) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          state.tokenize = inBlock(\"meta\", \"?>\");\n          return \"meta\";\n        } else {\n          type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n          state.tokenize = inTag;\n          return \"tag bracket\";\n        }\n      } else if (ch == \"&\") {\n        var ok;\n        if (stream.eat(\"#\")) {\n          if (stream.eat(\"x\")) {\n            ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n          } else {\n            ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n          }\n        } else {\n          ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n        }\n        return ok ? \"atom\" : \"error\";\n      } else {\n        stream.eatWhile(/[^&<]/);\n        return null;\n      }\n    }\n    inText.isInText = true;\n\n    function inTag(stream, state) {\n      var ch = stream.next();\n      if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n        state.tokenize = inText;\n        type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n        return \"tag bracket\";\n      } else if (ch == \"=\") {\n        type = \"equals\";\n        return null;\n      } else if (ch == \"<\") {\n        state.tokenize = inText;\n        state.state = baseState;\n        state.tagName = state.tagStart = null;\n        var next = state.tokenize(stream, state);\n        return next ? next + \" tag error\" : \"tag error\";\n      } else if (/[\\'\\\"]/.test(ch)) {\n        state.tokenize = inAttribute(ch);\n        state.stringStartCol = stream.column();\n        return state.tokenize(stream, state);\n      } else {\n        stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n        return \"word\";\n      }\n    }\n\n    function inAttribute(quote) {\n      var closure = function(stream, state) {\n        while (!stream.eol()) {\n          if (stream.next() == quote) {\n            state.tokenize = inTag;\n            break;\n          }\n        }\n        return \"string\";\n      };\n      closure.isInAttribute = true;\n      return closure;\n    }\n\n    function inBlock(style, terminator) {\n      return function(stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = inText;\n            break;\n          }\n          stream.next();\n        }\n        return style;\n      }\n    }\n\n    function doctype(depth) {\n      return function(stream, state) {\n        var ch;\n        while ((ch = stream.next()) != null) {\n          if (ch == \"<\") {\n            state.tokenize = doctype(depth + 1);\n            return state.tokenize(stream, state);\n          } else if (ch == \">\") {\n            if (depth == 1) {\n              state.tokenize = inText;\n              break;\n            } else {\n              state.tokenize = doctype(depth - 1);\n              return state.tokenize(stream, state);\n            }\n          }\n        }\n        return \"meta\";\n      };\n    }\n\n    function lower(tagName) {\n      return tagName && tagName.toLowerCase();\n    }\n\n    function Context(state, tagName, startOfLine) {\n      this.prev = state.context;\n      this.tagName = tagName || \"\";\n      this.indent = state.indented;\n      this.startOfLine = startOfLine;\n      if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n        this.noIndent = true;\n    }\n    function popContext(state) {\n      if (state.context) state.context = state.context.prev;\n    }\n    function maybePopContext(state, nextTagName) {\n      var parentTagName;\n      while (true) {\n        if (!state.context) {\n          return;\n        }\n        parentTagName = state.context.tagName;\n        if (!config.contextGrabbers.hasOwnProperty(lower(parentTagName)) ||\n            !config.contextGrabbers[lower(parentTagName)].hasOwnProperty(lower(nextTagName))) {\n          return;\n        }\n        popContext(state);\n      }\n    }\n\n    function baseState(type, stream, state) {\n      if (type == \"openTag\") {\n        state.tagStart = stream.column();\n        return tagNameState;\n      } else if (type == \"closeTag\") {\n        return closeTagNameState;\n      } else {\n        return baseState;\n      }\n    }\n    function tagNameState(type, stream, state) {\n      if (type == \"word\") {\n        state.tagName = stream.current();\n        setStyle = \"tag\";\n        return attrState;\n      } else if (config.allowMissingTagName && type == \"endTag\") {\n        setStyle = \"tag bracket\";\n        return attrState(type, stream, state);\n      } else {\n        setStyle = \"error\";\n        return tagNameState;\n      }\n    }\n    function closeTagNameState(type, stream, state) {\n      if (type == \"word\") {\n        var tagName = stream.current();\n        if (state.context && state.context.tagName != tagName &&\n            config.implicitlyClosed.hasOwnProperty(lower(state.context.tagName)))\n          popContext(state);\n        if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\n          setStyle = \"tag\";\n          return closeState;\n        } else {\n          setStyle = \"tag error\";\n          return closeStateErr;\n        }\n      } else if (config.allowMissingTagName && type == \"endTag\") {\n        setStyle = \"tag bracket\";\n        return closeState(type, stream, state);\n      } else {\n        setStyle = \"error\";\n        return closeStateErr;\n      }\n    }\n\n    function closeState(type, _stream, state) {\n      if (type != \"endTag\") {\n        setStyle = \"error\";\n        return closeState;\n      }\n      popContext(state);\n      return baseState;\n    }\n    function closeStateErr(type, stream, state) {\n      setStyle = \"error\";\n      return closeState(type, stream, state);\n    }\n\n    function attrState(type, _stream, state) {\n      if (type == \"word\") {\n        setStyle = \"attribute\";\n        return attrEqState;\n      } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n        var tagName = state.tagName, tagStart = state.tagStart;\n        state.tagName = state.tagStart = null;\n        if (type == \"selfcloseTag\" ||\n            config.autoSelfClosers.hasOwnProperty(lower(tagName))) {\n          maybePopContext(state, tagName);\n        } else {\n          maybePopContext(state, tagName);\n          state.context = new Context(state, tagName, tagStart == state.indented);\n        }\n        return baseState;\n      }\n      setStyle = \"error\";\n      return attrState;\n    }\n    function attrEqState(type, stream, state) {\n      if (type == \"equals\") return attrValueState;\n      if (!config.allowMissing) setStyle = \"error\";\n      return attrState(type, stream, state);\n    }\n    function attrValueState(type, stream, state) {\n      if (type == \"string\") return attrContinuedState;\n      if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n      setStyle = \"error\";\n      return attrState(type, stream, state);\n    }\n    function attrContinuedState(type, stream, state) {\n      if (type == \"string\") return attrContinuedState;\n      return attrState(type, stream, state);\n    }\n\n    return {\n      startState: function(baseIndent) {\n        var state = {tokenize: inText,\n                     state: baseState,\n                     indented: baseIndent || 0,\n                     tagName: null, tagStart: null,\n                     context: null}\n        if (baseIndent != null) state.baseIndent = baseIndent\n        return state\n      },\n\n      token: function(stream, state) {\n        if (!state.tagName && stream.sol())\n          state.indented = stream.indentation();\n\n        if (stream.eatSpace()) return null;\n        type = null;\n        var style = state.tokenize(stream, state);\n        if ((style || type) && style != \"comment\") {\n          setStyle = null;\n          state.state = state.state(type || style, stream, state);\n          if (setStyle)\n            style = setStyle == \"error\" ? style + \" error\" : setStyle;\n        }\n        return style;\n      },\n\n      indent: function(state, textAfter, fullLine) {\n        var context = state.context;\n        // Indent multi-line strings (e.g. css).\n        if (state.tokenize.isInAttribute) {\n          if (state.tagStart == state.indented)\n            return state.stringStartCol + 1;\n          else\n            return state.indented + indentUnit;\n        }\n        if (context && context.noIndent) return CodeMirror.Pass;\n        if (state.tokenize != inTag && state.tokenize != inText)\n          return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n        // Indent the starts of attribute names.\n        if (state.tagName) {\n          if (config.multilineTagIndentPastTag !== false)\n            return state.tagStart + state.tagName.length + 2;\n          else\n            return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n        }\n        if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n        var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n        if (tagAfter && tagAfter[1]) { // Closing tag spotted\n          while (context) {\n            if (context.tagName == tagAfter[2]) {\n              context = context.prev;\n              break;\n            } else if (config.implicitlyClosed.hasOwnProperty(lower(context.tagName))) {\n              context = context.prev;\n            } else {\n              break;\n            }\n          }\n        } else if (tagAfter) { // Opening tag spotted\n          while (context) {\n            var grabbers = config.contextGrabbers[lower(context.tagName)];\n            if (grabbers && grabbers.hasOwnProperty(lower(tagAfter[2])))\n              context = context.prev;\n            else\n              break;\n          }\n        }\n        while (context && context.prev && !context.startOfLine)\n          context = context.prev;\n        if (context) return context.indent + indentUnit;\n        else return state.baseIndent || 0;\n      },\n\n      electricInput: /<\\/[\\s\\w:]+>$/,\n      blockCommentStart: \"<!--\",\n      blockCommentEnd: \"-->\",\n\n      configuration: config.htmlMode ? \"html\" : \"xml\",\n      helperType: config.htmlMode ? \"html\" : \"xml\",\n\n      skipAttribute: function(state) {\n        if (state.state == attrValueState)\n          state.state = attrState\n      },\n\n      xmlCurrentTag: function(state) {\n        return state.tagName ? {name: state.tagName, close: state.type == \"closeTag\"} : null\n      },\n\n      xmlCurrentContext: function(state) {\n        var context = []\n        for (var cx = state.context; cx; cx = cx.prev)\n          context.push(cx.tagName)\n        return context.reverse()\n      }\n    };\n  });\n\n  CodeMirror.defineMIME(\"text/xml\", \"xml\");\n  CodeMirror.defineMIME(\"application/xml\", \"xml\");\n  if (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n    CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n  });"],"names":["mod","CodeMirror","htmlConfig","autoSelfClosers","implicitlyClosed","contextGrabbers","doNotIndent","allowUnquoted","allowMissing","caseFold","xmlConfig","allowMissingTagName","defineMode","editorConf","config_","type","setStyle","indentUnit","config","defaults","htmlMode","prop","inText","stream","state","chain","parser","tokenize","ch","next","eat","match","inBlock","eatWhile","doctype","inTag","quote","closure","baseState","tagName","tagStart","test","eol","isInAttribute","stringStartCol","column","style","terminator","depth","lower","toLowerCase","Context","startOfLine","prev","context","indent","indented","hasOwnProperty","noIndent","this","popContext","maybePopContext","nextTagName","parentTagName","tagNameState","closeTagNameState","current","attrState","matchClosing","closeState","closeStateErr","_stream","attrEqState","attrValueState","attrContinuedState","isInText","startState","baseIndent","token","sol","indentation","eatSpace","textAfter","fullLine","Pass","length","multilineTagIndentPastTag","multilineTagIndentFactor","alignCDATA","tagAfter","exec","grabbers","electricInput","blockCommentStart","blockCommentEnd","configuration","helperType","skipAttribute","xmlCurrentTag","name","close","xmlCurrentContext","cx","push","reverse","defineMIME","mimeModes","exports","module","require","define","amd"],"mappings":"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"}